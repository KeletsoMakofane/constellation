CREATE CONSTRAINT UniquePaperIdConstraint IF NOT EXISTS
ON (p:Paper)
ASSERT p.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Author)
ASSERT a.name IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Investigator)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Project)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Organization)
ASSERT a.id IS UNIQUE;

CREATE FULLTEXT INDEX NameFulltextIndex IF NOT EXISTS
FOR (n:Author) ON EACH [n.name];

CREATE INDEX race_index IF NOT EXISTS
FOR (p:Paper)
ON (p.race);

CREATE INDEX racism_index IF NOT EXISTS
FOR (p:Paper)
ON (p.racism);

CREATE INDEX covid_index IF NOT EXISTS
FOR (p:Paper)
ON (p.covid);

CREATE INDEX year_index IF NOT EXISTS
FOR (p:Paper)
ON (p.year);



############ Papers

:auto LOAD CSV FROM
'file:///papers_1.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_2.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_3.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_4.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_5.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_6.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];


:auto LOAD CSV FROM
'file:///papers_7.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_8.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_9.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_10.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_11.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_12.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_13.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_14.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_15.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_16.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_17.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_18.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_19.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];

:auto LOAD CSV FROM
'file:///papers_20.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Paper {id: row[1]})
ON CREATE SET
m.title = row[2],
m.abstract = row[3],
m.journal_id = row[4],
m.journal_title = row[5],
m.mesh_desc_major = row[6],
m.mesh_desc_nonmajor = row[7],
m.mesh_qual_major = row[8],
m.mesh_qual_major = row[9],
m.mesh_qual_nonmajor = row[10];





############ Authors

:auto using periodic commit
LOAD CSV FROM
'file:///authors.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Author {name: row[1]});

############ Investigators

:auto using periodic commit
LOAD CSV FROM
'file:///investigator_nodes.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Investigator {id: row[1]})
ON CREATE SET
m.name = row[2];

############ Projects

:auto using periodic commit
LOAD CSV FROM
'file:///project_nodes.csv' as row
WITH row WHERE row[1] IS NOT NULL
MERGE (m:Project {id: row[1]})
ON CREATE SET
m.title = row[2],
m.year = toInteger(row[3]),
m.indirect_cost = toInteger(row[4]),
m.direct_cost = toInteger(row[5]),
m.total_cost = toInteger(row[6]),
m.total_cost_subproject = toInteger(row[7]);


############ Organizations

:auto using periodic commit
LOAD CSV FROM
'file:///organization_nodes.csv' as row
MERGE (m:Organization {id: toInteger(row[1])}
ON CREATE SET
m.name = row[2],
m.city = row[3];

############ Authors and Papers

:auto using periodic commit
LOAD CSV FROM
'file:///author_paper_edges.csv' as row
MATCH (author:Author) WHERE toLower(author.name) = toLower(row[2])
MATCH (paper:Paper) WHERE toInteger(paper.id) = toInteger(row[1])
MERGE (author)-[:WROTE]->(paper);

############ Investigators and Projects

:auto using periodic commit
LOAD CSV FROM
'file:///investigator_project_edges.csv' as row
MATCH (i:Investigator) WHERE toInteger(i.id) = toInteger(row[1])
MATCH (p:Project) WHERE toInteger(p.id) = toInteger(row[2])
MERGE (i)-[:LED]->(p);

############ Organizations and Projects

:auto using periodic commit
LOAD CSV FROM
'file:///organization_project_edges.csv' as row
MATCH (o:Organization) WHERE toInteger(o.id) = toInteger(row[1])
MATCH (p:Project) WHERE toInteger(p.id) = toInteger(row[2])
MERGE (o)-[:HOSTED]->(p);

############ Project and Paper

:auto using periodic commit
LOAD CSV FROM
'file:///project_paper_edges.csv' as row
MATCH (o:Project ) WHERE toLower(o.name) = toLower(row[2])
MATCH (p:Paper ) WHERE toInteger(p.id) = toInteger(row[1])
MERGE (o)-[:SUPPORTED]->(p);


############ Project and SubProject

:auto using periodic commit
LOAD CSV FROM
'file:///project_subproject_edges.csv' as row
MATCH (o:Project) WHERE toInteger(o.id) = toInteger(row[2])
MATCH (p:Project ) WHERE toInteger(p.id) = toInteger(row[1])
MERGE (o)-[:BEGAT]->(p);




############ Paper Paper Citations

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///citations.csv' as row
MATCH (from:Paper {id: toInteger(row.from)})
MATCH (to:Paper {id: toInteger(row.to)})
MERGE (from)-[:CITED]->(to);

############ Coauthoring Communities


CALL gds.graph.create.cypher(
  'collaborationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]->(b:Paper)<-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(b) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;


CALL gds.labelPropagation.write('collaborationNetwork', { writeProperty: 'community' })
YIELD communityCount, ranIterations, didConverge;

CALL gds.graph.drop('collaborationNetwork');

############ Citation Practices


CALL gds.graph.create.cypher(
  'citationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]-(p:Paper)-[:CITED]->(:Paper)-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(p) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;

CALL gds.articleRank.write('citationNetwork', {
  writeProperty: 'auth_pagerank'
})
YIELD nodePropertiesWritten, ranIterations;

CALL gds.graph.drop('citationNetwork');






