CREATE CONSTRAINT UniquePaperIdConstraint IF NOT EXISTS
ON (p:Paper)
ASSERT p.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Author)
ASSERT a.name IS UNIQUE;

CREATE CONSTRAINT UniqueInvestigatorIdConstraint IF NOT EXISTS
ON (a:Investigator)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueProjectIdConstraint IF NOT EXISTS
ON (a:Project)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueOrganizationIdConstraint IF NOT EXISTS
ON (a:Organization)
ASSERT a.id IS UNIQUE;

CREATE FULLTEXT INDEX NameFulltextIndex IF NOT EXISTS
FOR (n:Author) ON EACH [n.name];

CREATE INDEX year_index IF NOT EXISTS
FOR (p:Paper)
ON (p.year);

CREATE INDEX project_key_index IF NOT EXISTS
FOR (p:Paper)
ON (p.project_key);



############ Papers

LOAD CSV WITH HEADERS FROM
'file:///papers.csv' as row
MERGE (m:Paper {id: row.id})
SET
m.title = row.title,
m.abstract = row.abstract,
m.journal_id = row.journal_id,
m.journal_title = row.journal_title,
m.mesh_desc_major = row.mesh_desc_major,
m.mesh_desc_nonmajor = row.mesh_desc_nonmajor,
m.mesh_qual_major = row.mesh_qual_major,
m.mesh_qual_major = row.mesh_qual_major,
m.mesh_qual_nonmajor = row.mesh_qual_nonmajor ;



############ Authors

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///authors.csv' as row
MERGE (m:Author {name: row.name_author});

############ Investigators

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///investigator_nodes.csv' as row
MERGE (m:Investigator {id: row.id_investigator})
ON CREATE SET
m.name = row.name_investigator;

############ Projects

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///project_nodes.csv' as row
MERGE (m:Project {id: row.id_project})
ON CREATE SET
m.title = row.title,
m.year = toInteger(row.year),
m.indirect_cost = toInteger(row.indirect_cost),
m.direct_cost = toInteger(row.direct_cost),
m.total_cost = toInteger(row.total_cost),
m.total_cost_subproject = toInteger(row.subproject);


############ Organizations

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///organization_nodes.csv' as row
MERGE (m:Organization {id: row.id_organization})
SET
m.name = row.name_organization,
m.city = row.city_organization;

############ Authors and Papers

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///author_paper_edges.csv' as row
MATCH (author:Author) WHERE author.name = row.name_author
MATCH (paper:Paper) WHERE paper.id = row.id_paper 
MERGE (author)-[:WROTE]->(paper);

############ Investigators and Projects

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///investigator_project_edges.csv' as row
MATCH (i:Investigator) WHERE i.id = row.id_investigator
MATCH (p:Project) WHERE p.id = row.id_project
MERGE (i)-[:LED]->(p);

############ Organizations and Projects

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///organization_project_edges.csv' as row
MATCH (o:Organization) WHERE o.id = row.id_organization
MATCH (p:Project) WHERE p.id = row.id_project
MERGE (o)-[:HOSTED]->(p);

############ Project and Paper


:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///project_paper_edges.csv' as row
MATCH (p:Paper) WHERE p.id = row.id_paper
SET p.project_key = row.id_project + '_' + p.year + '_0';

MATCH (p:Project), (q:paper)
WHERE p.id = q.project_key
MERGE (p)-[:SUPPORTED]->(q);


############ Project and SubProject

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///project_subproject_edges.csv' as row
MATCH (o:Project) WHERE o.id = row.id_project
MATCH (p:Project ) WHERE p.id = row.id_subproject
MERGE (o)-[:BEGAT]->(p);




############ Paper Paper Citations

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///citation_edges.csv' as row
MATCH (from:Paper {id: row.id_paper_from})
MATCH (to:Paper {id: row.id_paper_to})
MERGE (from)-[:CITED]->(to);

############ Coauthoring Communities


CALL gds.graph.create.cypher(
  'collaborationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]->(b:Paper)<-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(b) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;


CALL gds.labelPropagation.write('collaborationNetwork', { writeProperty: 'community' })
YIELD communityCount, ranIterations, didConverge;

CALL gds.graph.drop('collaborationNetwork');

############ Citation Practices


CALL gds.graph.create.cypher(
  'citationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]-(p:Paper)-[:CITED]->(:Paper)-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(p) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;

CALL gds.articleRank.write('citationNetwork', {
  writeProperty: 'auth_pagerank'
})
YIELD nodePropertiesWritten, ranIterations;

CALL gds.graph.drop('citationNetwork');






