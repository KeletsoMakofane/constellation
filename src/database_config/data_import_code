CREATE CONSTRAINT UniquePaperIdConstraint IF NOT EXISTS
ON (p:Paper)
ASSERT p.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Author)
ASSERT a.name IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Investigator)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Project)
ASSERT a.id IS UNIQUE;

CREATE CONSTRAINT UniqueAuthorIdConstraint IF NOT EXISTS
ON (a:Organization)
ASSERT a.id IS UNIQUE;

CREATE FULLTEXT INDEX NameFulltextIndex FOR (n:Author) ON EACH [n.name];

CREATE INDEX race_index IF NOT EXISTS
FOR (p:Paper)
ON (p.race);

CREATE INDEX racism_index IF NOT EXISTS
FOR (p:Paper)
ON (p.racism);

CREATE INDEX covid_index IF NOT EXISTS
FOR (p:Paper)
ON (p.covid);

CREATE INDEX year_index IF NOT EXISTS
FOR (p:Paper)
ON (p.year);



############ Papers

:auto LOAD CSV WITH HEADERS FROM
'file:///articles.csv' as row
MERGE (m:Paper {id: toInteger(row.id)})
ON CREATE SET
m.title = row.title,
m.year = toInteger(row.year),
m.race = row.race,
m.covid = row.covid,
m.racism = row.racism;


############ Authors

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///authors.csv' as row
MERGE (m:Author {name: row.forename + " " + row.lastname})
ON CREATE SET
m.forename = row.forename,
m.lastname = row.lastname,
m.initials = row.initials;

############ Investigators

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///investigator_nodes.csv' as row
MERGE (m:Investigator {id: row.id_investigator})
ON CREATE SET
m.name = row.name_investigator;

############ Projects

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///project_nodes.csv' as row
MERGE (m:Project {id: row.id_project})
ON CREATE SET
m.title = row.title,
m.year = toInteger(row.year),
m.indirect_cost = toInteger(row.indirect_cost),
m.direct_cost = toInteger(row.direct_cost),
m.total_cost = toInteger(row.total_cost),
m.total_cost_subproject = toInteger(row.total_cost_subproject);


############ Organizations

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///organization_nodes.csv' as row
MERGE (m:Organization {id: row.id_organization})
ON CREATE SET
m.name = row.name_organization,
m.city = row.city_organization;

############ Authors and Papers

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///authors.csv' as row
MATCH (author:Author {name: row.forename + " " + row.lastname})
MATCH (paper:Paper {id: toInteger(row.id)})
MERGE (author)-[:WROTE]->(paper);

############ Paper Paper Citations

:auto using periodic commit
LOAD CSV WITH HEADERS FROM
'file:///citations.csv' as row
MATCH (from:Paper {id: toInteger(row.from)})
MATCH (to:Paper {id: toInteger(row.to)})
MERGE (from)-[:CITED]->(to);

############ Coauthoring Communities


CALL gds.graph.create.cypher(
  'collaborationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]->(b:Paper)<-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(b) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;


CALL gds.labelPropagation.write('collaborationNetwork', { writeProperty: 'community' })
YIELD communityCount, ranIterations, didConverge;

CALL gds.graph.drop('collaborationNetwork');

############ Citation Practices


CALL gds.graph.create.cypher(
  'citationNetwork',
  'MATCH (n:Author) RETURN id(n) AS id, labels(n) AS labels',
  'MATCH (a:Author)-[:WROTE]-(p:Paper)-[:CITED]->(:Paper)-[:WROTE]-(b:Author)
    RETURN id(a) AS source, id(b) AS target, count(p) as weight'
)
YIELD
  graphName AS graph, nodeCount AS nodes, relationshipCount AS rels;

CALL gds.articleRank.write('citationNetwork', {
  writeProperty: 'auth_pagerank'
})
YIELD nodePropertiesWritten, ranIterations;

CALL gds.graph.drop('citationNetwork');






